#!/bin/bash

# Constants
COMMAND_NAME="-copy"  # Using - prefix to avoid special character conflicts
PREVIEW_LENGTH=60
DEFAULT_LIST_COUNT=10

# Function to copy text to clipboard (cross-platform)
copy_to_clipboard() {
    local text="$1"
    if command -v pbcopy >/dev/null 2>&1; then
        printf '%s' "$text" | pbcopy
    elif command -v xclip >/dev/null 2>&1; then
        printf '%s' "$text" | xclip -selection clipboard
    elif command -v clip.exe >/dev/null 2>&1; then
        local temp_file=$(mktemp)
        printf '\xEF\xBB\xBF%s' "$text" > "$temp_file"
        powershell.exe -Command "Get-Content -Path '$(wslpath -w "$temp_file")' -Encoding UTF8 | Set-Clipboard"
        rm "$temp_file"
    else
        echo "No clipboard utility found (pbcopy, xclip, or clip.exe)" >&2
        exit 1
    fi
}

# Read hook input
INPUT=$(cat)

# Quick pattern match without jq
PROMPT=""
if [[ "$INPUT" =~ \"prompt\":[[:space:]]*\"([^\"]+)\" ]]; then
    PROMPT="${BASH_REMATCH[1]}"
fi

# Check if this is our command
if [[ ! "$PROMPT" =~ ^${COMMAND_NAME}([[:space:]]+(-fr?[[:space:]]+.+|-ls([[:space:]]+[0-9]+)?|-debug([[:space:]]+[0-9]+)?|[0-9]+))?$ ]]; then
    exit 0
fi

# Now we need jq
if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is required. Install with: brew install jq" >&2
    exit 2
fi

# Parse hook input
TRANSCRIPT_PATH=$(echo "$INPUT" | jq -r '.transcript_path')
PROMPT=$(echo "$INPUT" | jq -r '.prompt')

if [ -z "$TRANSCRIPT_PATH" ] || [ ! -f "$TRANSCRIPT_PATH" ]; then
    echo "No valid transcript path found" >&2
    exit 1
fi

# Parse command arguments
LIST_MODE=false
FIND_MODE=false
REGEX_MODE=false
DEBUG_MODE=false
SEARCH_TERM=""
RESPONSE_NUM=1
LIST_COUNT=$DEFAULT_LIST_COUNT

if [[ "$PROMPT" =~ ^${COMMAND_NAME}[[:space:]]+-ls([[:space:]]+([0-9]+))?$ ]]; then
    LIST_MODE=true
    [[ -n "${BASH_REMATCH[2]}" ]] && LIST_COUNT=${BASH_REMATCH[2]}
elif [[ "$PROMPT" =~ ^${COMMAND_NAME}[[:space:]]+-fr[[:space:]]+(.+)$ ]]; then
    FIND_MODE=true
    REGEX_MODE=true
    SEARCH_TERM="${BASH_REMATCH[1]}"
elif [[ "$PROMPT" =~ ^${COMMAND_NAME}[[:space:]]+-f[[:space:]]+(.+)$ ]]; then
    FIND_MODE=true
    SEARCH_TERM="${BASH_REMATCH[1]}"
elif [[ "$PROMPT" =~ ^${COMMAND_NAME}[[:space:]]+-debug([[:space:]]+([0-9]+))?$ ]]; then
    DEBUG_MODE=true
    [[ -n "${BASH_REMATCH[2]}" ]] && RESPONSE_NUM=${BASH_REMATCH[2]}
elif [[ "$PROMPT" =~ ^${COMMAND_NAME}[[:space:]]+([0-9]+)$ ]]; then
    RESPONSE_NUM=${BASH_REMATCH[1]}
fi

# Single jq call to extract all responses grouped by requestId (newest first)
# Output format: JSON array of {text, timestamp} objects
RESPONSES_JSON=$(jq -s '
  [.[] | select(.message.role == "assistant")]
  | group_by(.requestId)
  | map({
      text: (map(.message.content[0].text // "") | join("")),
      timestamp: (.[0].timestamp // .[0].message.timestamp // null)
    })
  | map(select(.text | gsub("\\s"; "") | length > 0))
  | reverse
' "$TRANSCRIPT_PATH")

TOTAL_RESPONSES=$(echo "$RESPONSES_JSON" | jq 'length')

if [ "$TOTAL_RESPONSES" -eq 0 ]; then
    echo "No assistant text responses found" >&2
    exit 1
fi

# Helper to get response text by index (0-based)
get_response() {
    echo "$RESPONSES_JSON" | jq -r ".[$1].text"
}

# Helper to get timestamp by index (0-based)
get_timestamp() {
    echo "$RESPONSES_JSON" | jq -r ".[$1].timestamp // empty"
}

# Helper to format time ago
format_time_ago() {
    local timestamp="$1"
    [[ -z "$timestamp" || "$timestamp" == "null" ]] && return

    local now_epoch=$(date +%s)
    local msg_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "${timestamp%%.*}" +%s 2>/dev/null || echo "$now_epoch")
    local diff=$((now_epoch - msg_epoch))

    if [[ $diff -lt 60 ]]; then
        printf "[%3ds ago]" "$diff"
    elif [[ $diff -lt 3600 ]]; then
        printf "[%3dm ago]" "$((diff/60))"
    else
        printf "[%3dh ago]" "$((diff/3600))"
    fi
}

# Helper to generate preview
generate_preview() {
    local text="$1"
    local preview=$(echo "$text" | grep -m1 -v '^[[:space:]]*$' | cut -c1-$PREVIEW_LENGTH)
    [[ -z "$preview" ]] && preview="<empty>"
    [[ ${#preview} -eq $PREVIEW_LENGTH ]] && preview="${preview}..."
    echo "$preview"
}

# Handle find mode
if [ "$FIND_MODE" = true ]; then
    if [ "$REGEX_MODE" = true ]; then
        echo "Regex search for \"$SEARCH_TERM\":" >&2
    else
        echo "Searching for \"$SEARCH_TERM\":" >&2
    fi
    found=0
    for ((i=0; i<TOTAL_RESPONSES; i++)); do
        text=$(get_response $i)
        if [ "$REGEX_MODE" = true ]; then
            match=$(echo "$text" | grep -Eqi "$SEARCH_TERM" 2>/dev/null && echo "yes")
        else
            match=$(echo "$text" | grep -Fqi "$SEARCH_TERM" && echo "yes")
        fi
        if [ "$match" = "yes" ]; then
            ((found++))
            preview=$(generate_preview "$text")
            time_ago=$(format_time_ago "$(get_timestamp $i)")
            printf "  %3d %s: %s\n" "$((i+1))" "$time_ago" "$preview" >&2
        fi
    done
    [[ $found -eq 0 ]] && echo "No matches found" >&2 || echo "Found $found matches" >&2
    exit 2
fi

# Handle list mode
if [ "$LIST_MODE" = true ]; then
    show=$((TOTAL_RESPONSES < LIST_COUNT ? TOTAL_RESPONSES : LIST_COUNT))
    echo "Responses (1-$TOTAL_RESPONSES, showing $show):" >&2
    for ((i=0; i<show; i++)); do
        preview=$(generate_preview "$(get_response $i)")
        time_ago=$(format_time_ago "$(get_timestamp $i)")
        printf "  %3d %s: %s\n" "$((i+1))" "$time_ago" "$preview" >&2
    done
    exit 2
fi

# Validate response number
if [ "$RESPONSE_NUM" -lt 1 ] || [ "$RESPONSE_NUM" -gt "$TOTAL_RESPONSES" ]; then
    echo "Invalid #$RESPONSE_NUM (valid: 1-$TOTAL_RESPONSES)" >&2
    exit 2
fi

# Get selected response (convert to 0-based index)
SELECTED=$(get_response $((RESPONSE_NUM-1)))

# Handle debug mode
if [ "$DEBUG_MODE" = true ]; then
    echo "=== DEBUG ===" >&2
    echo "$SELECTED" >&2
    echo "" >&2
    echo "Bytes: $(printf '%s' "$SELECTED" | wc -c | tr -d ' ')" >&2
    echo "Chars: $(printf '%s' "$SELECTED" | wc -m | tr -d ' ')" >&2
fi

# Copy to clipboard
copy_to_clipboard "$SELECTED"

# Output result
if [ "$DEBUG_MODE" = true ]; then
    exit 2
elif [ "$RESPONSE_NUM" -eq 1 ]; then
    echo '{"decision": "block", "reason": "Latest response copied!"}'
else
    echo '{"decision": "block", "reason": "Response #'"$RESPONSE_NUM"' copied!"}'
fi